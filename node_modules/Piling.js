var utility = require('utility/utility');

var Syntax = {
    AssignmentExpression: 'AssignmentExpression',//表达式: 赋值 (无需打桩)
    ArrayExpression: 'ArrayExpression',//表达式: 数组 [] (无需打桩)
    ArrayPattern: 'ArrayPattern',//??
    BlockStatement: 'BlockStatement',//块 静态块 {} (打桩)
    BinaryExpression: 'BinaryExpression',//*表达式: 运算1+2 (无需打桩)
    BreakStatement: 'BreakStatement',//*块 break块
    CallExpression: 'CallExpression',//表达式 函数调用 run() (无需打桩)
    CatchClause: 'CatchClause',//块 catch (无需打桩)
    ComprehensionBlock: 'ComprehensionBlock',//??
    ComprehensionExpression: 'ComprehensionExpression',//表达式 ??
    ConditionalExpression: 'ConditionalExpression',//表达式 条件 1? 1 : 0 (无需打桩)
    ContinueStatement: 'ContinueStatement',//*块 continue块
    DirectiveStatement: 'DirectiveStatement',//块 ??
    DoWhileStatement: 'DoWhileStatement',//块 (无需打桩，但无blockStatement时要主动加上)
    DebuggerStatement: 'DebuggerStatement',//*块 debugger;
    EmptyStatement: 'EmptyStatement',//*块 就是分号
    ExpressionStatement: 'ExpressionStatement',//块 (无需打桩)
    ForStatement: 'ForStatement',//块 for循环块 (无需打桩，但无blockStatement时要主动加上)
    ForInStatement: 'ForInStatement',//块 forIn块 (无需打桩，但无blockStatement时要主动加上)
    FunctionDeclaration: 'FunctionDeclaration',// fn声明 (无需打桩)
    FunctionExpression: 'FunctionExpression',//表达式 函数表达式 function(){} (无需打桩)
    Identifier: 'Identifier',//(无需打桩)
    IfStatement: 'IfStatement',//块 if块 (无需打桩，但无blockStatement时要主动加上)
    Literal: 'Literal',
    LabeledStatement: 'LabeledStatement',//块 标签块，如：a: 100 (无需打桩)
    LogicalExpression: 'LogicalExpression',//表达式 逻辑表达式 0||1 (无需打桩)
    MemberExpression: 'MemberExpression',//表达式 出现在调用对象方法中 a.b() a为MemberExpression (无需打桩)
    NewExpression: 'NewExpression',//表达式 new表达式 (无需打桩)
    ObjectExpression: 'ObjectExpression',//表达式 对象表达式 {} (无需打桩)
    ObjectPattern: 'ObjectPattern',//??
    Program: 'Program', //(打桩)
    Property: 'Property',// (无需打桩)
    ReturnStatement: 'ReturnStatement',//*块 return块
    SequenceExpression: 'SequenceExpression',//表达式 顺序表达式 如: x=10, y=10; (无需打桩)
    SwitchStatement: 'SwitchStatement',//块 switch (无需打桩,无静态块表示)
    SwitchCase: 'SwitchCase', //switch-case块 (打桩)
    ThisExpression: 'ThisExpression',//表达式 this表达式 (无需打桩)
    ThrowStatement: 'ThrowStatement',//块 throw块 (无需打桩)
    TryStatement: 'TryStatement',//块 try块 (无需打桩)
    UnaryExpression: 'UnaryExpression',//表达式 '非'或是 void 运算表达式 (无需打桩)
    UpdateExpression: 'UpdateExpression',//表达式 i++, i-- (无需打桩)
    VariableDeclaration: 'VariableDeclaration',// (无需打桩)
    VariableDeclarator: 'VariableDeclarator',// (无需打桩)
    WhileStatement: 'WhileStatement',//块 while块 (无需打桩，但无blockStatement时要主动加上)
    WithStatement: 'WithStatement',//with块 (无需打桩，但无blockStatement时要主动加上)
    YieldExpression: 'YieldExpression'//表达式 yield表达式
};



var addBlockStatement = function(){
    var blockSyntax = [Syntax.IfStatement, Syntax.ForInStatement, Syntax.ForStatement, Syntax.WhileStatement, Syntax.DoWhileStatement, Syntax.WithStatement].join(','),
        blockEmptyIf = [Syntax.BlockStatement, Syntax.EmptyStatement, Syntax.IfStatement].join(','),
        blockEmpty = [Syntax.BlockStatement, Syntax.EmptyStatement].join(',');
    function getBlockStatement(){
        var args = [].slice.call(arguments),
            ret = {
                "type": "BlockStatement",
                "body": []
            };
        ret.body = ret.body.concat(args);
        return ret;
    }
    function resBlock(stmt){
        var isPlain = utility.isPlainObject(stmt);
        if(!utility.isArray(stmt) && !isPlain){return;}
        (isPlain ? Object.keys(stmt) : stmt).forEach(function(item, index){
            isPlain && (item = stmt[item]);
            resBlock(item);
        });
        if(!~blockSyntax.indexOf(stmt.type)){return;}
        var isIfStmt = 'consequent' in stmt,
            array = isIfStmt ? ['consequent', 'alternate'] : ['body'],
            str = isIfStmt ? blockEmptyIf : blockEmpty,
            item;
        array.forEach(function(val){
            item = stmt[val];
            if(!item || ~str.indexOf(item.type)){return;}
            stmt[val] = getBlockStatement(item);
        });
        return stmt;
    }
    return resBlock;
}();

var recursion = function(){
        var blockProgram = [Syntax.Program, Syntax.BlockStatement, Syntax.SwitchCase].join(',');
        function getTrackerFunction(codeId, lineNum){
            return {
                "type": "ExpressionStatement",
                "expression": {
                    "type": "CallExpression",
                    "callee": {
                        "type": "Identifier",
                        "name": "_tracker_"
                    },
                    "arguments": [
                        {
                            "type": "Literal",
                            "value": codeId,
                            "raw": '"' + codeId + '"'
                        },
                        {
                            "type": "Literal",
                            "value": lineNum,
                            "raw": lineNum + ""
                        }
                    ]
                }
            };
        }
        
        /**
         * 
         * @param {Object} mapping
         * @param {Object} loc
         * @param {Object} options
         * @param {Number} options.key
         * @param {Array} options.merge
         */
        function setMapping(mapping, loc, options){
            var opts = options || {},
                line = loc.start.line,
                column = loc.start.column,
                key = opts.key || line,
                merge = opts.merge,
                source = mapping[key] || (mapping[key] = {});
                item = source[line] || (source[line] = {});
            item.start = item.start === undefined ? column : Math.min(item.start, column);
            if(line !== loc.end.line){
                line = loc.end.line;
                column = loc.end.column;
                item = source[line] || (source[line] = {});
                item.end = Math.max(item.end || 0, column);
            }
            merge && merge.forEach(function(item){
                item = mapping[item];
                if(!item){return;}
                Object.keys(item).forEach(function(val){
                    var mInst = item[val],
                        sInst = source[val];
                    if(!mInst){return;}
                    if(sInst){
                        mInst.start && (sInst.start = sInst.start === undefined ? mInst.start : Math.min(sInst.start, mInst.start));
                        mInst.end && (sInst.end = Math.max(sInst.end || 0, mInst.end));
                    }else{
                        source[val] = mInst;
                    }
                });
            });
         }
        
        function getFn(fnName, codeId, ident){
            return {
                "type": "ExpressionStatement",
                "expression": {
                    "type": "CallExpression",
                    "callee": {
                        "type": "Identifier",
                        "name": fnName
                    },
                    "arguments": [
                        {
                            "type": "Literal",
                            "value": codeId,
                            "raw": "'" + codeId + "'"
                        },
                        {
                            "type": "Literal",
                            "value": ident,
                            "raw": "'" + ident + "'"
                        }
                    ]
                }
            }
        }
        
        
        /**
         * mapping: mapping['1'] = {line: }
         * BlockStatement: 需要在内块内部第一行打桩，映射范围
         */
        function rec(stmt, codeId, mapping){
            var isPlain = utility.isPlainObject(stmt);
            if(!utility.isArray(stmt) && !isPlain){return;}
            var type = stmt.type,
                prop = type === Syntax.SwitchCase ? 'consequent' : 'body',
                body = ~blockProgram.indexOf(type) ? stmt[prop] : [],
                clone = [],
                item;
            mapping = mapping || {};
            (isPlain ? Object.keys(stmt) : stmt).forEach(function(item, index){
                isPlain && (item = stmt[item]);
                rec(item, codeId, mapping);
            });
            
            //这里加入其它情况
            switch(type){//这个switch会递归至底层
                case Syntax.BlockStatement://在前面打桩，映射范围
                case Syntax.SwitchCase:
                    body.length && clone.push(getTrackerFunction(codeId, stmt.loc.start.line));
                    setMapping(mapping, stmt.loc);
                    break;
                case Syntax.IfStatement:
                    var line = stmt.loc.start.line,
                        item = mapping[line],
                        val = item && item[line],
                        elseStatement = stmt.alternate;
                    val && (val.start = stmt.loc.start.column);
                    if(!elseStatement){return;}
                    line = elseStatement.loc.start.line;
                    item = mapping[line];
                    val = item && item[line];
                    val && (val.start = item[line].start - 5);
                    break;
                case Syntax.TryStatement:
                case Syntax.CatchClause:
                    var line = stmt.loc.start.line,
                        item = mapping[line],
                        finalizer = stmt.finalizer;
                    item[line].start = stmt.loc.start.column;
                    if(finalizer){//如果存在finally
                        line = finalizer.loc.start.line;
                        item = mapping[line];
                        item[line].start = item[line].start - 8;
                    }
                    break;
                case Syntax.ArrayExpression:
                    //为每个内容建立mapping，但不建立tracker
                    var merge = [];
                    stmt.elements.forEach(function(item){
                        if(!item){return;}
                        setMapping(mapping, item.loc);
                        merge.push(item.loc.start.line);
                    });
//                    setMapping(mapping, stmt.loc, {key: stmt.loc.end.line, merge: merge});
                    setMapping(mapping, stmt.loc, {merge: merge});
                    break;
                case Syntax.ObjectExpression:
                    var merge = [];
                    stmt.properties.forEach(function(item){
                        setMapping(mapping, item.loc);
                        merge.push(item.loc.start.line);
                    });
                    setMapping(mapping, stmt.loc, {merge: merge});
                    break;
                case Syntax.VariableDeclaration:
                    var array = stmt.declarations,
                        merge = [];
                    if(array.length > 1){
                        array.forEach(function(item){
                            merge.push(item.loc.start.line);
                        });
                    }
                    setMapping(mapping, stmt.loc, {merge: merge});
                    break;
                case Syntax.VariableDeclarator:
                    var item = stmt.init;
                    if(item && item.loc.start.line !== item.loc.end.line){
                        setMapping(mapping, stmt.loc, {merge: [item.loc.start.line]});
                    }
                    break;
                case Syntax.CallExpression:
                    var array = stmt.arguments,
                        merge = [],
                        line, val;
                    if(array.length){
                        array.forEach(function(item, index){
                            line = item.loc.start.line;
                            merge.push(item.loc.start.line);
                            if(index){return;}
                            val = mapping[line];
                            val && (val[line].start = val[line].start - 1);//把执行语句的左半边括号加入运算
                        });
                    }
                    setMapping(mapping, stmt.loc, {merge: merge});
                    stmt
                    break;
                default: break;
            }
            
            //在这里为每一项后面打桩，防止桩也被加入到递归运算中
            if(!body.length){return;}
            body.forEach(function(val, index){
                clone.push(val);
                switch(val.type){
                    case Syntax.EmptyStatement:
                    case Syntax.TryStatement:
                    case Syntax.IfStatement:
                        return;
                    case Syntax.ThrowStatement:
                    case Syntax.ContinueStatement:
                    case Syntax.BreakStatement://需要在前面加入tracker
                        clone.splice(clone.length - 1, 0, getTrackerFunction(codeId, val.loc.start.line));
                        setMapping(mapping, val.loc);
                        return;
                    case Syntax.ReturnStatement:
                        var args = val.argument,
                            expr = getTrackerFunction(codeId, val.loc.start.line).expression;
                        val.argument = args ? {"type": "SequenceExpression", "expressions": [expr, args]} : expr;
                        setMapping(mapping, val.loc);
                        return;
                    case Syntax.FunctionDeclaration:
                        var c = val.body.body;
                        c.unshift(getFn('_fnStart_', 'codeId', 'ident'));
                        c.push(getFn('_fnEnd_', 'codeId', 'ident'))
                        break;
                    default: break;
                }
                clone.push(getTrackerFunction(codeId, val.loc.start.line));
                setMapping(mapping, val.loc);
            });
            stmt[prop] = clone;
            return {ast: stmt, mapping: mapping};
        }
        return rec;
    }();




exports.addBlockStatement = addBlockStatement;
exports.recursion = recursion;